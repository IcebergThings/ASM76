//=============================================================================
// ■ VVector.hpp
//-----------------------------------------------------------------------------
//   A naïve implementation of variable-sized array.
//=============================================================================

template <
	class T,
	// Sometimes we'd like to reserve the memory but destruct this class.
	// In these case should cleanup be false.
	bool cleanup = true
> class Vector {
	//-------------------------------------------------------------------------
	// ● 实例变量
	//-------------------------------------------------------------------------
private:
	size_t capacity; // number of objects
public:
	T* start;
	T* end;
	//-------------------------------------------------------------------------
	// ● 构造
	//   initial_capacity : number of objects of which to be reserved space
	//-------------------------------------------------------------------------
	Vector(size_t initial_capacity = 10) {
		capacity = initial_capacity;
		start = end = (T*) malloc(capacity * sizeof(T));
	}
	//-------------------------------------------------------------------------
	// ● 析构
	//-------------------------------------------------------------------------
	~Vector() {
		if (cleanup) free(start);
	}
	//-------------------------------------------------------------------------
	// ● 获取元素
	//-------------------------------------------------------------------------
	T& operator[](size_t i) {
		return start[i];
	}
	//-------------------------------------------------------------------------
	// ● 获取元素个数
	//-------------------------------------------------------------------------
	size_t size() {
		return end - start;
	}
	//-------------------------------------------------------------------------
	// ● 在末尾追加元素
	//-------------------------------------------------------------------------
	void push(T x) {
		size_t count = size();
		if (count >= capacity) {
			capacity += capacity >> 1;
			// 检查什么空指针？！
			// 如果连内存都搞不到，这个程序运行着还有什么意义？
			start = (T*) realloc(start, capacity * sizeof(T));
			// end may be invalidated
			end = start + count;
		}
		*end++ = x;
	}
	//-------------------------------------------------------------------------
	// ● 获取末尾元素并丢弃之
	//-------------------------------------------------------------------------
	T pop() {
		assert(end > start);
		end--;
		return *end;
	}
};
